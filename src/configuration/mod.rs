use std::{collections::HashMap, fs, path::PathBuf};

use config::{self, File, FileFormat};
use crossterm::event::KeyCode;
use directories::ProjectDirs;
use log::{error, info, warn};
use serde::Deserialize;
use tui::style::Color;

pub mod actions;
mod general;
mod theme;
use actions::{Action, ActionMap};
use general::General;
use theme::Theme;

const DEFAULT_CONFIG: &'static str = include_str!("../../default_config.toml");

// Intermediate config struct generated by serde.
// If the ActionMap can be converted to HashMap<KeyCode, Vec<Action>>
// in the custom Deserialize then this middle step would not be needed.
#[derive(Debug, Deserialize)]
pub struct IConfig {
    theme: Theme,
    actions: ActionMap,
    general: General,
}

// Final config that is actually used by the app.
// TODO - Write user updated template string to file
#[derive(Debug)]
pub struct Config {
    theme: Theme,
    actions: HashMap<KeyCode, Vec<Action>>,
    keys: HashMap<Action, KeyCode>,
    general: General,
}

impl Config {
    pub fn new() -> Self {
        info!("{}", "Building new config");
        let conf = if let Some(s) = get_config_file_string() {
            config::Config::builder()
                .add_source(File::from_str(DEFAULT_CONFIG, FileFormat::Toml))
                .add_source(File::with_name(&s))
                .build()
                .unwrap()
        } else {
            config::Config::builder()
                .add_source(File::from_str(DEFAULT_CONFIG, FileFormat::Toml))
                .build()
                .unwrap()
        };

        match conf.clone().try_deserialize::<IConfig>() {
            Ok(c) => get_config(c),
            Err(e) => {
                error!("Using default config - {}", e);
                let c = config::Config::builder()
                    .add_source(File::from_str(DEFAULT_CONFIG, FileFormat::Toml))
                    .build()
                    .unwrap()
                    .try_deserialize::<IConfig>()
                    .unwrap();

                get_config(c)
            }
        }
    }

    pub fn basic_fg(&self) -> Color {
        self.theme.basic_fg.into()
    }

    pub fn basic_bg(&self) -> Color {
        self.theme.basic_bg.into()
    }

    pub fn window_border(&self) -> Color {
        self.theme.window_border.into()
    }

    pub fn window_title(&self) -> Color {
        self.theme.window_title.into()
    }

    pub fn secondary_title(&self) -> Color {
        self.theme.secondary_title.into()
    }

    pub fn active_window_title(&self) -> Color {
        self.theme.active_window_title.into()
    }

    pub fn active_border(&self) -> Color {
        self.theme.active_border.into()
    }

    pub fn list_highlighted_fg(&self) -> Color {
        self.theme.list_highlighted_fg.into()
    }

    pub fn list_highlighted_bg(&self) -> Color {
        self.theme.list_highlighted_bg.into()
    }

    pub fn list_active_fg(&self) -> Color {
        self.theme.list_active_fg.into()
    }

    pub fn list_active_bg(&self) -> Color {
        self.theme.list_active_bg.into()
    }

    pub fn list_directory(&self) -> Color {
        self.theme.list_directory_fg.into()
    }

    pub fn log_error_fg(&self) -> Color {
        self.theme.log_error_fg.into()
    }

    pub fn log_info_fg(&self) -> Color {
        self.theme.log_info_fg.into()
    }

    pub fn log_trace_fg(&self) -> Color {
        self.theme.log_trace_fg.into()
    }

    pub fn log_warn_fg(&self) -> Color {
        self.theme.log_warn_fg.into()
    }

    pub fn get_actions(&self, key: &KeyCode) -> Option<&Vec<Action>> {
        self.actions.get(key)
    }

    pub fn get_key(&self, action: &Action) -> Option<&KeyCode> {
        self.keys.get(action)
    }

    pub fn get_template_string(&self) -> String {
        self.general.template_string.clone()
    }
}

pub fn get_config_file_string() -> Option<String> {
    if let Some(dirs) = ProjectDirs::from("rid3", "rid3", "rid3") {
        let path_buf = dirs.config_dir().join("config.toml");

        if path_buf.exists() {
            Some(path_buf.into_os_string().into_string().unwrap())
        } else {
            warn!("No user config.toml file found. Using default config.");
            None
        }
    } else {
        warn!("No user config directory found. Using default config.");
        None
    }
}

pub fn get_config_dir() -> Option<PathBuf> {
    if let Some(dirs) = ProjectDirs::from("rid3", "rid3", "rid3") {
        Some(PathBuf::from(dirs.config_dir()))
    } else {
        None
    }
}

// Convert the HashMap<Action, KeyCode> of the intermediate IConfig to
// HashMap<KeyCode, Vec<Action>> of the final Config struct.
fn get_config(i_conf: IConfig) -> Config {
    let general = i_conf.general;
    let theme = i_conf.theme;
    let mut keys = HashMap::new();

    let mut actions: HashMap<KeyCode, Vec<Action>> = HashMap::new();

    for (action, keycode) in i_conf.actions.0.iter() {
        let mut v = match actions.get(&keycode.0) {
            Some(v) => v.clone(),
            None => vec![],
        };

        v.push(*action);
        actions.insert(keycode.0, v);
        keys.insert(*action, keycode.0);
    }

    Config {
        theme,
        actions,
        keys,
        general,
    }
}

// Update configuration file with new template_string
pub fn update_config(template_string: &str) -> Result<(), anyhow::Error> {
    if let Some(dir) = get_config_dir() {
        let path_buf = dir.join("config.toml");
        if path_buf.exists() {
            let mut contents: Vec<String> = fs::read_to_string(&path_buf)?
                .split('\n')
                .map(|s| s.to_owned())
                .collect();

            // TODO - This code assumes that the config file contains a `[general]` table
            //        with a `template_string` value. One or both of these may be missing
            //        which will need to be handled.
            for line in contents.iter_mut() {
                if line.starts_with("template_string") {
                    *line = format!("template_string = '{}'", template_string);
                    break;
                }
            }

            let s = contents.join("\n");
            fs::write(path_buf, s)?;
        }
    }
    Ok(())
}
