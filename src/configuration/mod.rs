use std::{collections::HashMap, path::PathBuf};

use config::{self, File, FileFormat};
use crossterm::event::KeyCode;
use directories::ProjectDirs;
use log::{error, info, warn};
use serde::Deserialize;
use tui::style::Color;

mod actions;
use actions::{Action, ActionMap};
mod theme;
use theme::Theme;

const DEFAULT_CONFIG: &str = r#"
    [theme]
    list_item_fg = 'LightGreen'
    list_item_bg = 'Reset'
    active_list_item_fg = 'LightYellow'
    active_list_item_bg = 'DarkGray'
    inactive_list_item_fg = 'LightGreen'
    inactive_list_item_bg = 'DarkGray'

    help_border = 'LightYellow'

    log_error_fg = 'Red'
    log_info_fg = 'Blue'
    log_trace_fg = 'DarkGray'
    log_warn_fg = 'Yellow'

    [actions]
    up = 'Up'
    down = 'Down'
    quit = 'q'
    switch_focus = 'Tab'
"#;

// Intermediate config struct generated by serde.
// If the ActionMap can be converted to HashMap<KeyCode, Vec<Action>>
// in the custom Deserialize then this middle step would not be needed.
#[derive(Debug, Deserialize)]
pub struct IConfig {
    theme: Theme,
    actions: ActionMap,
}

// Final config that is actually used by the app.
#[derive(Debug)]
pub struct Config {
    theme: Theme,
    actions: HashMap<KeyCode, Vec<Action>>,
}

impl Config {
    pub fn new() -> Self {
        info!("{}", "Building new config");
        let conf = if let Some(s) = get_config_file_string() {
            config::Config::builder()
                .add_source(File::from_str(DEFAULT_CONFIG, FileFormat::Toml))
                .add_source(File::with_name(&s))
                .build()
                .unwrap()
        } else {
            config::Config::builder()
                .add_source(File::from_str(DEFAULT_CONFIG, FileFormat::Toml))
                .build()
                .unwrap()
        };

        match conf.clone().try_deserialize::<IConfig>() {
            Ok(c) => get_config(c),
            Err(e) => {
                error!("Using default config - {}", e);
                let c = config::Config::builder()
                    .add_source(File::from_str(DEFAULT_CONFIG, FileFormat::Toml))
                    .build()
                    .unwrap()
                    .try_deserialize::<IConfig>()
                    .unwrap();

                get_config(c)
            }
        }
    }

    pub fn list_item_fg(&self) -> Color {
        self.theme.list_item_fg.into()
    }

    pub fn list_item_bg(&self) -> Color {
        self.theme.list_item_bg.into()
    }

    pub fn active_list_item_fg(&self) -> Color {
        self.theme.active_list_item_fg.into()
    }

    pub fn active_list_item_bg(&self) -> Color {
        self.theme.active_list_item_bg.into()
    }

    pub fn inactive_list_item_fg(&self) -> Color {
        self.theme.inactive_list_item_fg.into()
    }

    pub fn inactive_list_item_bg(&self) -> Color {
        self.theme.inactive_list_item_bg.into()
    }

    pub fn help_border(&self) -> Color {
        self.theme.help_border.into()
    }

    pub fn log_error_fg(&self) -> Color {
        self.theme.log_error_fg.into()
    }

    pub fn log_info_fg(&self) -> Color {
        self.theme.log_info_fg.into()
    }

    pub fn log_trace_fg(&self) -> Color {
        self.theme.log_trace_fg.into()
    }

    pub fn log_warn_fg(&self) -> Color {
        self.theme.log_warn_fg.into()
    }
}

pub fn get_config_file_string() -> Option<String> {
    if let Some(dirs) = ProjectDirs::from("rid3", "rid3", "rid3") {
        let path_buf = dirs.config_dir().join("config.toml");

        if path_buf.exists() {
            Some(path_buf.into_os_string().into_string().unwrap())
        } else {
            warn!("No user config.toml file found. Using default config.");
            None
        }
    } else {
        warn!("No user config directory found. Using default config.");
        None
    }
}

pub fn get_config_dir() -> Option<PathBuf> {
    if let Some(dirs) = ProjectDirs::from("rid3", "rid3", "rid3") {
        Some(PathBuf::from(dirs.config_dir()))
    } else {
        None
    }
}

// Convert the HashMap<Action, KeyCode> of the intermediate IConfig to
// HashMap<KeyCode, Vec<Action>> of the final Config struct.
fn get_config(i_conf: IConfig) -> Config {
    let theme = i_conf.theme;

    let mut actions: HashMap<KeyCode, Vec<Action>> = HashMap::new();

    for (action, keycode) in i_conf.actions.0.iter() {
        let mut v = match actions.get(&keycode.0) {
            Some(v) => v.clone(),
            None => vec![],
        };

        v.push(*action);
        actions.insert(keycode.0, v);
    }

    Config { theme, actions }
}
